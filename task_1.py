"""
Задание 1.
Реализуйте свои пользовательские функции, в которых реализуйте:
a) заполнение списка и словаря,
   сделайте замеры и сделайте выводы, что выполняется быстрее и почему
   И укажите сложность каждой ф-ции, которую вы применяете для заполнения.
   У этих ф-ций может быть разная сложность. Поэтому время заполнения списка и словаря может как совпадать,
   так и отличаться.
b) выполните набор операций и со списком, и со словарем,
   сделайте замеры и сделайте выводы, что и где выполняется быстрее и почему
   И укажите сложность ф-ций, которые вы используете для операций.
Подсказка: для замеров воспользуйтесь модулем time (см. примеры урока 1)
Примечание: если вы уже знаете, что такое декоратор и как его реализовать,
то реализуйте ф-цию-декоратор для подсчета времени работы ваших пользовательских функций
И примените ее к своим функциям!
Прошу вас внимательно читать ТЗ и не забыть выполнить все пункты.
"""

from time import time


def time_exec(func):
    """
    Функция-декоратор для замера времени выполнения функций
    """
    def timer(arg):
        start = time()
        result = func(arg)
        end = time()
        print(f'*** Результат выполнения функции {func.__name__}: {end - start} секунд')
        return result

    return timer


@time_exec
def get_lst_append(amount_el):
    """
    Функция создания и заполнения списка добавлением элементов в конец списка
    Сложность O(n) - линейная
    """
    lst = []  # O(1)
    for i in range(amount_el):  # O(n)
        lst.append(i)  # O(1)
    return lst  # O(1)


@time_exec
def get_lst_insert(amount_el):
    """
    Функция создания и заполнения списка добавлением элементов в начало списка
    Сложность O(n^2) - квадратичная
    """
    lst = []  # O(1)
    for i in range(amount_el):  # O(n)
        lst.insert(0, i)  # O(n)
    return lst  # O(1)


@time_exec
def get_dict(amount_el):
    """
    Функция создания и заполнения словаря
    Сложность O(n) - линейная
    """
    dic = {}  # O(1)
    for i in range(amount_el):  # O(n)
        dic[i] = i  # O(1)
    return dic  # O(1)


@time_exec
def el_in_lst(lst):
    """
    Функция проверки на входимость 5000 элементов в список
    Сложность O(n) - линейная
    """
    for i in range(50000, 55000):  # O(1)
        if i in lst:  # O(n)
            pass  # O(1)


@time_exec
def el_in_dic(dic):
    """
    Функция проверки на входимость 5000 элементов в словарь
    Сложность O(1) - константная
    """
    for i in range(50000, 55000):  # O(1)
        if i in dic:  # O(1)
            pass  # O(1)


@time_exec
def del_el_lst(lst):
    """
    Функция удаления 10000 элементов в середине списка
    Сложность O(n) - линейная
    """
    for i in range(50000, 60000):  # O(1)
        lst.pop(i)  # O(n)


@time_exec
def del_el_dic(dic):
    """
    Функция удаления 10000 элементов в словаре
    Сложность O(1) - константная
    """
    for i in range(50000, 60000):  # O(1)
        dic.pop(i)  # O(1)


# Задание a:
lst_1 = get_lst_append(100000)  # 0.006995201110839844 секунд
lst_2 = get_lst_insert(100000)  # 2.6754603385925293 секунд
dic_1 = get_dict(100000)  # 0.008993864059448242 секунд
# Как и ожидалось, функция с квадратичной сложностью выполнения (get_lst_insert)
# выполняется значительно дольше остальных функций, у которых линейная сложность.
# Не смотря на одинаковую линейную сложность у функций get_lst_append и get_dict,
# фуннция get_lst_append выполняется на 10-50% быстрее функции get_dict.
# Можно предположить, что при создании словаря тратится дополнительное время
# на выполнение хеш-функции и создание хеш-таблицы.

# Задание b:
el_in_lst(lst_1)  # 3.386958599090576 секунд
el_in_dic(dic_1)  # 0.00099945068359375 секунд
# Функция входимости элементов в список более чем в 3000!!! раз выполняется дольше,
# чем функция входимости элементов в словарь. Причем, чем дальше проверяемые элементы
# списка от начала списка, тем дольше время выполнения функции.
# Разность в линейной и константной сложности функций.

del_el_lst(lst_1)  # 0.1089332103729248 секунд
del_el_dic(dic_1)  # 0.0019989013671875 секунд
# Удаление элементов из словаря более чем в 50 раз выполняется дольше, чем из списка.
# Разность в линейной и константной сложности функций.
