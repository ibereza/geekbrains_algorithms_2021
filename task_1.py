from random import randint
from timeit import timeit


def bubble_sort_inverse_1(arr):
    """
    Функция пузырьковой сортировки методом
    убывания элементов (от большего к меньшему)
    """
    n = 1
    while n < len(arr):
        for i in reversed(range(n, len(arr))):
            if arr[i] < arr[i - 1]:
                arr[i], arr[i - 1] = arr[i - 1], arr[i]

        n += 1
    return arr


def bubble_sort_inverse_2(arr):
    """
    Функция пузырьковой сортировки методом
    убывания элементов (от большего к меньшему),
    плюс оптимизация с отслеживанием окончания сортировки
    """
    n = 1
    while n < len(arr):
        array_sorted = True
        for i in reversed(range(n, len(arr))):
            if arr[i] < arr[i - 1]:
                arr[i], arr[i - 1] = arr[i - 1], arr[i]
                array_sorted = False
        if array_sorted:
            return arr
        n += 1
    return arr


def bubble_sort_inverse_3(arr):
    """
    Функция пузырьковой сортировки методом
    убывания элементов (от большего к меньшему),
    плюс оптимизация сокращения перестановок в массиве
    (нименьший элемент переставляется не сразу, а
    только после прохождения всего массива)
    """
    n = 0
    while n < len(arr) - 1:
        index_min_el = len(arr) - 1
        min_el = arr[index_min_el]

        for i in reversed(range(n, len(arr) - 1)):
            if arr[i] < min_el:
                min_el = arr[i]
                index_min_el = i

        arr[n], arr[index_min_el] = arr[index_min_el], arr[n]
        n += 1
    return arr


num_list = [randint(-100, 100) for _ in range(10)]
print('Не сортированный массив:')
print(num_list)
print('Массив отсортирован пузырьковой сортировкой по убыванию:')
print(bubble_sort_inverse_1(num_list[:]))
print('Массив отсортирован пузырьковой сортировкой по убыванию')
print('и оптимизацией "отслеживание окончания сортировки":')
print(bubble_sort_inverse_2(num_list[:]))
print('Массив отсортирован пузырьковой сортировкой по убыванию')
print('и оптимизацией "сокращения перестановок в массиве":')
print(bubble_sort_inverse_3(num_list[:]))

# Замеры
for num_cycles in (10, 100, 1000):
    num_list = [randint(-100, 100) for _ in range(num_cycles)]
    if num_cycles == 10:
        number_tests = 100000
    elif num_cycles == 100:
        number_tests = 1000
    else:
        number_tests = 10
    print(f'Массив из {num_cycles} элементов:')
    print('*************************')
    print('Пузырьковая сортировка убыванием:')
    print(timeit('bubble_sort_inverse_1((num_list[:]))',
                 globals=globals(),
                 number=number_tests))
    print('Пузырьковая сортировка убыванием ', end='')
    print('и оптимизацией "отслеживание окончания сортировки":')
    print(timeit('bubble_sort_inverse_2((num_list[:]))',
                 globals=globals(),
                 number=number_tests))
    print('Пузырьковая сортировка убыванием ', end='')
    print('и оптимизацией "сокращение перестановок в массиве":')
    print(timeit('bubble_sort_inverse_3((num_list[:]))',
                 globals=globals(),
                 number=number_tests))
    print('*************************')

"""
Результаты тестов:

Массив из 10 элементов:
*************************
Пузырьковая сортировка убыванием:
0.9550150000000001
Пузырьковая сортировка убыванием и оптимизацией "отслеживание окончания сортировки":
0.8649844999999998
Пузырьковая сортировка убыванием и оптимизацией "сокращение перестановок в массиве":
0.8351099
*************************
Массив из 100 элементов:
*************************
Пузырьковая сортировка убыванием:
0.7697177000000002
Пузырьковая сортировка убыванием и оптимизацией "отслеживание окончания сортировки":
0.7592882000000003
Пузырьковая сортировка убыванием и оптимизацией "сокращение перестановок в массиве":
0.2584609000000002
*************************
Массив из 1000 элементов:
*************************
Пузырьковая сортировка убыванием:
0.8883535
Пузырьковая сортировка убыванием и оптимизацией "отслеживание окончания сортировки":
0.8294819000000002
Пузырьковая сортировка убыванием и оптимизацией "сокращение перестановок в массиве":
0.2552349999999999
*************************

Выводы:

1. Оптимизация "отслеживание окончания сортировки" основана на том предположении,
что в процессе сортировки в лучшем случае массив окажется отсортированным за половину
итераций по сравнению со стандартной сортировкой, а в худшем случае - за то же время.
Делать лишние итерации нет смысла. Экономия должна дать в среднем 25%. 
В результате, оптимизация оказалась не существенной, особенно пр увеличении массива.
2. Оптимизация "сокращения перестановок в массиве" основана на том предположении,
что операции перестановок элементов в массиве занимают существенное время и их 
уменьшение сократит время выполнения функции. Поэтому перестановка минимального 
элемента массива выполнялась не в процессе выполнения цикла, а только по его завершению.
В результате, оптимизация дала хорошие результаты, особенно при увеличении массива 
(почти в 4 раза). 

Чуть позже понял, что при оптимизации 2 получил алгоритм сортировки выбором. :)))
В любом случае, можно сделать вывод, что несмотря на то, что у обоих алгоритмов скорость
O(n2), благодаря уменьшению перестановок внутри массива, сортировка выбором работает
быстрее пузырьковой сортировки.  
"""
